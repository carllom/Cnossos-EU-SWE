#pragma once
/* 
 * ------------------------------------------------------------------------------------------------
 * file:		ReferenceObject.h
 * version:		1.0
 * author:		dirk.van-maercke@cstb.fr
 * copyright:	see file licence.CSTB.txt
 * description: definition of intrusive smart pointers and automatic memory management
 * changes:
 *
 *	28/11/2013	this header and licensing conditions added
 * ------------------------------------------------------------------------------------------------- 
 */
#include <typeinfo>
#include <string>
#include <assert.h>

namespace System
{
	extern long atomic_increment (volatile long *x) ;
	extern long atomic_decrement (volatile long *x) ;

	class ReferenceObject ;
	/*!
	 * basis for all referenced counted dynamic objects
	 *
	 * if the library requires a pointer to something as a return value, the application
	 * has two options :
	 *
	 *	1) pass on the pointer returned by a new statement. In this case, the library will
	 *     first assign this pointer to a ref_ptr and when the ref_ptr goes out of scope, the
	 *	   object will be destroyed
	 *
	 *  2) the application created the object and saves the pointer in a permanent ref_ptr,
	 *     on request of the library, the application returns the permanent object as a 
	 *     standard pointer
	 *
	 * don't do this :
	 *
	 *			SomeObject* getSomeObject (void)
	 *			{
	 *				ref_ptr<SomeObject> obj = new SomeObject() :
	 *				return obj ;
	 *			}
	 *
	 * on return from the function, the ref_ptr goes out of scope and the object will be
	 * deleted before the caller gets a chance to use the newly created object.
	 *
	 * this is OK (and easier to write) :
	 *
	 *			SomeObject* getSomeObject (void)
	 *			{
	 *				return new SomeObject() :
	 *				return obj ;
	 *			}
	 *
	 * alternatively, if you need a ref_ptr in the local context, e.g. in case you need to 
	 * throw some exception, use :
	 *
	 *			SomeObject* getSomeObject (void)
	 *			{
	 *				ref_ptr<SomeObject> obj = new SomeObject() :
	 *				//
	 *				// your code that might throw an exception
	 *				//
	 *				return obj.take() ;
	 *			}
	 *
	 * this will disconnect the pointer from the reference holder and pass on the standard
	 * pointer to the library...
	 */
	class ReferenceObject
	{
	public:

		ReferenceObject (void) : refCount(0)
		{
		}

		virtual ~ReferenceObject (void) 
		{ 
		}

		ReferenceObject (ReferenceObject const& other) : refCount(0)
		{
		}

	protected:
				
		template <typename T> friend class ref_ptr ;

		void addref (void) 
		{ 
			atomic_increment (&refCount) ; 
		}

		bool unref (void)
		{
			assert (refCount > 0) ;
			atomic_decrement (&refCount) ;
			return refCount == 0 ;
		}

		void unref_nodelete (void)
		{
			atomic_decrement (&refCount) ;
		}

	private:

		ReferenceObject& operator= (ReferenceObject const&) ;
		volatile long refCount ;
	};

	/*
	 * ref_ptr acts as a smart pointer by holding a reference to a dynamically created 
	 * ReferenceObject and keeping track of a usage counter ; the object will be deleted 
	 * when the last ref_ptr to it is destroyed (i.e. is removed from a container, goes 
	 * out of scope, is destroyed as part of another object, etc...)
	 */
	template <class T>
	class ref_ptr
	{
	public:
		/*
		 * construct and initialize with null pointer
		 */
		ref_ptr (void) : obj(0)	{ } ;
		/*
		 * construct from standard pointer
		 */
		ref_ptr (T const* _obj) : obj((T*) _obj)
		{
			if (obj) obj->addref() ;
		}
		/*
		 * copy-construct
		 */
		ref_ptr (ref_ptr<T> const& other) : obj (other.obj)
		{
			if (obj) obj->addref() ;
		}
		/*
		 * delete pointer, if no longer referenced, delete pointed object
		 */
		~ref_ptr (void)
		{
			if (obj && obj->unref()) delete obj ;
		}
		/* 
		 * assignment
		 */
		ref_ptr<T>& operator= (T const* _obj)
		{
			if (obj != _obj)
			{
				T* tmp = obj ;
				obj = (T*) _obj ; 
				if (obj) obj->addref() ;
				if (tmp && tmp->unref()) delete tmp ;
			}
			return *this ;
		}
		/*!
		 * for some obscure reason, we need both versions of the assignment operator
		 * in most cases, the compiler will accept the first version and automatically
		 * convert the argument from ref_ptr<T> to (T const*) 
		 *
		 * but exceptionally, it will use a default assignment operator operator (one that
		 * is automatically generated by the compiler) and than we're in BIG trouble !
		 *
		 * strange enough, the bug only occurs in debug mode... It took quite some hours 
		 * to found out what was going on and to find out that the alternative version is 
		 * required and sufficient to help the compiler getting things right...
		 */
		ref_ptr<T>& operator= (ref_ptr<T> const& other)
		{
			return this->operator= ((T const*) other) ;
		}
		/*
		 * TODO : transform const references into const pointers
		 *
		 * this however, requires a lot of changes in all classes that use ReferenceObject 
		 * as a base class, i.e. all get functions should be qualified as const...
		 */
		T* operator-> (void) const { return obj ; }
		operator T* (void) const { return obj ; }
		T* get (void) const { return obj ; }
		/*
		 * for checking null pointer, use !obj or !!obj
		 */
		bool operator! () const { return obj == 0 ; }
		/*! 
		 * convert permanently to normal pointer, giving up ownership of the pointee object ; 
		 * this is the inverse of assignment and/or initialization	by means of a standard pointer.
		*/
		T* take (void)
		{
			if (obj) obj->unref_nodelete() ;
			T* tmp = obj ;
			obj = 0 ;
			return tmp ;
		}
		/*
		 * cast to a different (derived) pointer type 
		 */
		template <class U> U* cast_to_ptr(void) { return dynamic_cast<U*>(obj) ; }

	private:
		T* obj ;
	};
}
